/**
 * @group Constants
 * @remarks List all errors generated by the backend with their descriptions
 */
declare const Error$1: {
    readonly NO_ACTIVITY: "Session closed due to no activity.";
    readonly WRONG_CREDENTIALS: "Application credentials are invalid. Please check or regenerate your application key and hmackey.";
    readonly TOO_OLD: "Session is too old. Max Session Duration Reached.";
    readonly UNKNOW: "An unknown error has occurred.";
    readonly ABNORMAL_CLOSURE: "MyScript recognition server is not reachable.";
    readonly CANT_ESTABLISH: "Unable to establish a connection to MyScript recognition server. Check the host and your connectivity.";
    readonly GOING_AWAY: "MyScript recognition server is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.";
    readonly PROTOCOL_ERROR: "MyScript recognition server terminated the connection due to a protocol error.";
    readonly UNSUPPORTED_DATA: "MyScript recognition server terminated the connection because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)";
    readonly INVALID_FRAME_PAULOAD: "MyScript recognition server terminated the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message).";
    readonly POLICY_VIOLATION: "MyScript recognition server terminated the connection because it received a message that violates its policy.";
    readonly MESSAGE_TOO_BIG: "MyScript recognition server terminated the connection because a data frame was received that is too large.";
    readonly INTERNAL_ERROR: "MyScript recognition server terminated the connection because it encountered an unexpected condition that prevented it from fulfilling the request.";
    readonly SERVICE_RESTART: "MyScript recognition server terminated the connection because it is restarting.";
    readonly TRY_AGAIN: "MyScript recognition server terminated the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients.";
    readonly BAD_GATEWAY: "MyScript recognition server was acting as a gateway or proxy and received an invalid response from the upstream server.";
    readonly TLS_HANDSHAKE: "MyScript recognition server connection was closed due to a failure to perform a TLS handshake";
};
/**
 * @group Constants
 * @group Event
 * @description Lists all events that can be listened to on the editor or DOM element
 */
declare const EventType: {
    /**
     * @description event emitted when history has changed i.e. the context of undo-redo
     */
    readonly CHANGED: "changed";
    /**
     * @description event emitted when clearing is complete
     */
    readonly CLEARED: "cleared";
    /**
     * @description event emitted after the conversion is complete
     */
    readonly CONVERTED: "converted";
    /**
     * @description event emitted when the editor encounters an error
     */
    readonly ERROR: "error";
    /**
     * @description event emitted on click on pointer events
     */
    readonly POINTEREVENTS: "pointer_events";
    /**
     * @description event emitted after the end of the export
     */
    readonly EXPORTED: "exported";
    /**
     * @description event emitted after the end of the import
     */
    readonly IMPORTED: "imported";
    /**
     * @description event emitted when the server is idle after a job
     */
    readonly IDLE: "idle";
    /**
     * @description event emitted after full editor initialization
     */
    readonly LOADED: "loaded";
};
/**
 * @group Constants
 * @group Event
 * @description Lists all internal library events
 */
declare const InternalEventType: {
    readonly SVG_PATCH: "internal_svg_patch";
    readonly EXPORTED: "internal_exported";
    readonly CLEAR_MESSAGE: "internal_clear_message";
    readonly ERROR: "internal_error";
    readonly NOTIF: "internal_notif";
    readonly IMPORT_JIIX: "internal_import_jiix";
    readonly CONVERT: "internal_convert";
    readonly CLEAR: "internal_clear";
    readonly CONTEXT_CHANGE: "internal_context_change";
    readonly IDLE: "internal_idle";
    readonly WS_CLOSED: "internal_websocket_closed";
};
/**
 * @group Editor
 * @group Constants
 * @group Model/Export
 * @description List all supported MIME types for export. Please note, the MIME types supported depend on the recognition type configured
 */
declare const enum ExportType {
    JIIX = "application/vnd.myscript.jiix",
    TEXT = "text/plain",
    LATEX = "application/x-latex",
    MATHML = "application/mathml+xml",
    SVG = "image/svg+xml",
    OFFICE_DOCUMENT = "application/vnd.openxmlformats-officedocument.presentationml.presentation"
}
/**
 * @group Constants
 * @group Editor
 * @description List the possibilities of interactions
 */
declare const enum Intention {
    Write = "write",
    Erase = "erase"
}
/**
 * @group Constants
 * @group Logger
 */
declare const enum LoggerLevel {
    DEBUG = "1",
    INFO = "2",
    WARN = "3",
    ERROR = "4"
}
/**
 * @group Constants
 * @group Logger
 */
declare const enum LoggerClass {
    EDITOR = "EDITOR",
    RECOGNIZER = "RECOGNIZER",
    GRABBER = "GRABBER",
    BEHAVIORS = "BEHAVIORS",
    CONFIGURATION = "CONFIGURATION",
    PUBLIC_EVENT = "PUBLIC_EVENT",
    MODEL = "MODEL",
    RENDERER = "RENDERER",
    SMARTGUIDE = "SMARTGUIDE",
    STYLE = "STYLE",
    UNDO_REDO = "UNDO_REDO",
    STROKE = "STROKE",
    INTERNAL_EVENT = "INTERNAL_EVENT"
}

/**
 * @group Utils
 */
declare class DeferredPromise<T> {
    promise: Promise<T>;
    resolve: (value: T) => void;
    reject: (value: Error | string) => void;
    isFullFilled: boolean;
    isPending: boolean;
    constructor();
}

/**
 * @group Primitive
 */
type TPoint = {
    x: number;
    y: number;
};
/**
 * @group Primitive
 */
type TPointer = TPoint & {
    t: number;
    p: number;
};
/**
 * @group Primitive
 */
type TSegment = {
    p1: TPoint;
    p2: TPoint;
};
/**
 * @group Primitive
 */
type TBoundingBox = {
    x: number;
    y: number;
    width: number;
    height: number;
};

/**
 * @group Style
 * @property {String} color=#000000 Color (supported formats rgb() rgba() hsl() hsla() #rgb #rgba #rrggbb #rrggbbaa)
 * @property {String} width in px

 */
type TStyle = {
    color?: string;
    width?: number;
    fill?: string;
};

/**
 * @group Style
 * @property {String} -myscript-pen-width=1 Width of strokes and primitives in mm (no other unit is supported yet)
 * @property {String} -myscript-pen-fill-style=none
 * @property {String} -myscript-pen-fill-color=#FFFFFF00 Color filled inside the area delimited by strokes and primitives
 */
type TPenStyle = TStyle & {
    "-myscript-pen-width"?: number;
    "-myscript-pen-fill-style"?: string;
    "-myscript-pen-fill-color"?: string;
};
/**
 * @group Style
 */
declare const DefaultPenStyle: TPenStyle;

/**
 * @group Style
 */
type TThemeMath = {
    "font-family": string;
};
/**
 * @group Style
 */
type TThemeMathSolved = {
    "font-family": string;
    color: string;
};
/**
 * @group Style
 */
type TThemeText = {
    "font-family": string;
    "font-size": number;
};
/**
 * @group Style
 */
type TTheme = {
    ink: TPenStyle;
    ".math": TThemeMath;
    ".math-solved": TThemeMathSolved;
    ".text": TThemeText;
    [key: string]: unknown;
};
/**
 * @group Style
 */
declare const DefaultTheme: TTheme;

/**
 * @group Style
 */
declare const StyleHelper: {
    themeToCSS(json: TTheme): string;
    themeToJSON(style: string): TTheme;
    penStyleToCSS(penStyle: TPenStyle): string;
    penStyleToJSON(penStyleString: string): TPenStyle;
    stringToJSON(style: string): {
        [key: string]: string;
    };
    JSONToString(style: {
        [key: string]: string;
    }): string;
};

/**
 * @group Style
 */
declare class StyleManager {
    #private;
    constructor(penStyle?: PartialDeep<TPenStyle>, theme?: PartialDeep<TTheme>);
    get currentPenStyle(): TPenStyle;
    get penStyle(): TPenStyle;
    setPenStyle(style?: PartialDeep<TPenStyle>): void;
    get theme(): TTheme;
    setTheme(theme?: PartialDeep<TTheme>): void;
    get penStyleClasses(): string;
    setPenStyleClasses(penStyleClass?: string): void;
}

declare const enum SymbolType {
    Stroke = "stroke",
    Shape = "shape",
    Text = "text"
}
/**
 * @group Primitive
 */
type TSymbol = {
    id: string;
    creationTime: number;
    modificationDate: number;
    type: SymbolType | string;
    style: TStyle;
};
/**
 * @group Primitive
 */
declare abstract class AbstractSymbol {
    id: string;
    creationTime: number;
    modificationDate: number;
    type: SymbolType;
    style: TStyle;
    constructor(type: SymbolType, style: TStyle);
    abstract getClone(): AbstractSymbol;
}

/**
 * @group Primitive/Canvas
 */
type TCanvasShapeEllipseSymbol = TSymbol & {
    centerPoint: TPoint;
    maxRadius: number;
    minRadius: number;
    orientation: number;
    startAngle: number;
    sweepAngle: number;
    beginDecoration?: string;
    endDecoration?: string;
    beginTangentAngle: number;
    endTangentAngle: number;
};
/**
 * @group Primitive/Canvas
 */
type TCanvasShapeLineSymbol = TSymbol & {
    firstPoint: TPoint;
    lastPoint: TPoint;
    beginDecoration?: string;
    endDecoration?: string;
    beginTangentAngle: number;
    endTangentAngle: number;
};
/**
 * @group Primitive/Canvas
 */
type TCanvasShapeTableLineSymbol = {
    p1: TPoint;
    p2: TPoint;
};
/**
 * @group Primitive/Canvas
 */
type TCanvasShapeTableSymbol = TSymbol & {
    lines: TCanvasShapeTableLineSymbol[];
};
/**
 * @group Primitive/Canvas
 */
type TCanvasUnderLineSymbol = TSymbol & {
    data: {
        firstCharacter: number;
        lastCharacter: number;
    };
};
/**
 * @group Primitive/Canvas
 */
type TCanvasTextSymbol = TSymbol & {
    label: string;
    data: {
        topLeftPoint: TPoint;
        height: number;
        width: number;
        textHeight: number;
        justificationType: string;
    };
};
/**
 * @group Primitive/Canvas
 */
type TCanvasTextUnderlineSymbol = TCanvasTextSymbol & {
    underlineList: TCanvasUnderLineSymbol[];
};

/**
 * @group Primitive
 */
type TStrokeToSend = {
    id: string;
    pointerType: string;
    x: number[];
    y: number[];
    t: number[];
    p: number[];
};
/**
 * @group Primitive
 */
type TStrokeGroupToSend = {
    penStyle?: string;
    strokes: TStrokeToSend[];
};
/**
 * @group Primitive
 */
type TStroke = TSymbol & {
    pointerId: number;
    pointerType: string;
    pointers: TPointer[];
    length: number;
};
/**
 * @group Primitive
 */
type TStrokeGroup = {
    penStyle: TPenStyle;
    strokes: Stroke[];
};
/**
 * @group Primitive
 */
declare class Stroke extends AbstractSymbol implements TStroke {
    #private;
    pointerId: number;
    pointerType: string;
    pointers: TPointer[];
    length: number;
    style: TPenStyle;
    constructor(style: TPenStyle, pointerId: number, pointerType?: string);
    getClone(): Stroke;
    formatToSend(): TStrokeToSend;
}
/**
 * @group Primitive
 * @group Utils
 */
declare function convertPartialStrokesToStrokes(json: PartialDeep<TStroke>[]): Stroke[];

/**
 * @group Utils
 */
declare function computeDistance(p1: TPoint, p2: TPoint): number;
/**
 * @group Utils
 */
declare function computeAngleAxeRadian(begin: TPoint, end: TPoint): number;
/**
 * @group Utils
 */
declare function createPointsOnSegment(p1: TPoint, p2: TPoint, spaceBetweenPoint?: number): TPoint[];
/**
 * @group Utils
 */
declare function scalaire(v1: TPoint, v2: TPoint): number;
/**
 * @group Utils
 */
declare function computeNearestPointOnSegment(p: TPoint, seg: TSegment): TPoint;
/**
 * @group Utils
 */
declare function computeDistanceBetweenPointAndSegment(p: TPoint, seg: TSegment): number;

/**
 * @group Utils
 */
declare const isVersionSuperiorOrEqual: (source: string, target: string) => boolean;

/**
 * @group Utils
 */
declare function computeHmac(message: string, applicationKey: string, hmacKey: string): Promise<string>;

/**
 * @group Utils
 */
declare function convertMillimeterToPixel(mm: number): number;
/**
 * @group Utils
 */
declare function convertPixelToMillimeter(px: number): number;

/**
 * @group Utils
 */
declare function createUUID(): string;

/**
 * @group Math
 */
declare function isBetween(val: number, min: number, max: number): boolean;

/**
 * @group Utils
 */
declare const mergeDeep: (target: any, ...sources: any[]) => any;

/**
 * @group Utils
 */
type PartialDeep<T> = T extends object ? {
    [P in keyof T]?: PartialDeep<T[P]>;
} : T;

/**
 * @group Utils
 */
declare function getAvailableFontList(configuration: PartialDeep<TConfiguration>): Promise<Array<string>>;

/**
 * @group Utils
 */
declare function getAvailableLanguageList(configuration: PartialDeep<TConfiguration>): Promise<Array<Record<string, string>>>;

/**
 * @group Utils
 */
declare function computeLinksPointers(point: TPointer, angle: number, width: number): TPoint[];
/**
 * @group Utils
 */
declare function computeMiddlePointer(point1: TPointer, point2: TPointer): TPointer;

/**
 * @group Configuration
 */
type TListenerConfiguration = {
    capture: boolean;
    passive: boolean;
};
/**
 * @group Configuration
 */
declare const DefaultListenerConfiguration: TListenerConfiguration;
/**
 * @group Configuration
 */
type TGrabberConfiguration = {
    listenerOptions: TListenerConfiguration;
    xyFloatPrecision: number;
    timestampFloatPrecision: number;
};
/**
 * @group Configuration
 */
declare const DefaultGrabberConfiguration: TGrabberConfiguration;

/**
 * @group Configuration
 */
type TEraserConfiguration = {
    "erase-precisely": boolean;
};
/**
 * @group Configuration
 */
declare const DefaultEraserConfiguration: TEraserConfiguration;

/**
 * @group Configuration
 */
type TMarginConfiguration = {
    bottom: number;
    left: number;
    right: number;
    top: number;
};
/**
 * @group Configuration
 */
declare const DefaultMarginConfiguration: TMarginConfiguration;

/**
 * @group Configuration
 */
type TTextGuidesConfiguration = {
    enable: boolean;
};
/**
 * @group Configuration
 */
declare const DefaultTextGuidesConfiguration: TTextGuidesConfiguration;
/**
 * @group Configuration
 */
type TTextConfConfiguration = {
    customResources?: string[];
    customLexicon?: string[];
    addLKText?: boolean;
};
/**
 * @group Configuration
 */
type TTextConfiguration = {
    text?: boolean;
    mimeTypes: ("text/plain" | "application/vnd.myscript.jiix")[];
    margin: TMarginConfiguration;
    guides?: TTextGuidesConfiguration;
    configuration?: TTextConfConfiguration;
    eraser?: TEraserConfiguration;
};
/**
 * @group Configuration
 */
declare const DefaultTextConfiguration: TTextConfiguration;

/**
 * @group Configuration
 */
type TDiagramConvertConfiguration = {
    edge?: boolean;
    node?: boolean;
    text?: boolean;
    "match-text-size"?: boolean;
};
/**
 * @group Configuration
 */
type TDiagramConfiguration = {
    mimeTypes: ("application/vnd.myscript.jiix" | "application/vnd.openxmlformats-officedocument.presentationml.presentation" | "image/svg+xml")[];
    "enable-sub-blocks"?: boolean;
    text?: TTextConfConfiguration;
    convert?: TDiagramConvertConfiguration;
    "session-time"?: number;
    eraser?: TEraserConfiguration;
};
/**
 * @group Configuration
 */
declare const DefaultDiagramConvertConfiguration: TDiagramConvertConfiguration;
/**
 * @group Configuration
 */
declare const DefaultDiagramConfiguration: TDiagramConfiguration;

/**
 * @group Configuration
 */
type TImageViewportConfiguration = {
    x: number;
    y: number;
    width: number;
    height: number;
};
/**
 * @group Configuration
 */
type TImageConfiguration = {
    guides: boolean;
    viewport: TImageViewportConfiguration;
};
/**
 * @group Configuration
 */
type TJiixConfiguration = {
    "bounding-box"?: boolean;
    strokes: boolean;
    text?: {
        chars: boolean;
        words: boolean;
    };
    style?: boolean;
};
/**
 * @group Configuration
 */
declare const DefaultJiixConfiguration: TJiixConfiguration;
/**
 * @group Configuration
 */
type TMathMLFlavor = {
    name: string;
};
/**
 * @group Configuration
 */
type TMathMLExport = {
    flavor: TMathMLFlavor;
};
/**
 * @group Configuration
 */
type TExportConfiguration = {
    "image-resolution"?: number;
    image?: TImageConfiguration;
    jiix?: TJiixConfiguration;
    mathml?: TMathMLExport;
};
/**
 * @group Configuration
 */
declare const DefaultExportConfiguration: TExportConfiguration;

/**
 * @group Configuration
 */
type TRoundingMode = "half up" | "truncate";
/**
 * @group Configuration
 */
type TAngleUnit = "deg" | "rad";
/**
 * @group Configuration
 */
type TSolverOptions = "algebraic" | "numeric";
/**
 * @group Configuration
 */
type TSolverConfiguration = {
    enable?: boolean;
    "fractional-part-digits"?: number;
    "decimal-separator"?: string;
    "rounding-mode"?: TRoundingMode;
    "angle-unit"?: TAngleUnit;
    options?: TSolverOptions;
};
/**
 * @group Configuration
 */
declare const DefaultSolverConfiguration: TSolverConfiguration;
/**
 * @group Configuration
 */
type TUndoRedoMode = "stroke" | "session";
/**
 * @group Configuration
 */
type TMathUndoRedoConfiguration = {
    mode: TUndoRedoMode;
};
/**
 * @group Configuration
 */
declare const DefaultMathUndoRedoConfiguration: TMathUndoRedoConfiguration;
/**
 * @group Configuration
 */
type TMathConfiguration = {
    mimeTypes: ("application/x-latex" | "application/mathml+xml" | "application/vnd.myscript.jiix")[];
    solver?: TSolverConfiguration;
    margin: TMarginConfiguration;
    "undo-redo"?: TMathUndoRedoConfiguration;
    customGrammar?: string;
    customGrammarId?: string;
    customGrammarContent?: string;
    eraser?: TEraserConfiguration;
    "session-time"?: number;
    "recognition-timeout"?: number;
};
/**
 * @group Configuration
 */
declare const DefaultMathConfiguration: TMathConfiguration;

/**
 * @group Configuration
 */
type TRawContentRecognitionConfiguration = {
    text: boolean;
    shape: boolean;
};
/**
 * @group Configuration
 */
declare const DefaultRawContentRecognitionConfiguration: TRawContentRecognitionConfiguration;
/**
 * @group Configuration
 */
type TRawContentConfiguration = {
    text?: TTextConfConfiguration;
    "session-time"?: number;
    recognition?: TRawContentRecognitionConfiguration;
    eraser?: TEraserConfiguration;
};
/**
 * @group Configuration
 */
declare const DefaultRawContentConfiguration: TRawContentConfiguration;

/**
 * @group Configuration
 */
type TRecognitionRendererDebugConfiguration = {
    "draw-text-boxes": boolean;
    "draw-image-boxes": boolean;
};
/**
 * @group Configuration
 */
declare const DefaultDebugConfiguration: TRecognitionRendererDebugConfiguration;
/**
 * @group Configuration
 */
type TRecognitionRendererConfiguration = {
    debug: TRecognitionRendererDebugConfiguration;
};
/**
 * @group Configuration
 */
declare const DefaultRecognitionRendererConfiguration: TRecognitionRendererConfiguration;

type TConvertionConfiguration = {
    force?: {
        "on-stylesheet-change": boolean;
    };
};
declare const DefaultConvertionConfiguration: TConvertionConfiguration;

/**
 * @group Configuration
 */
type TRecognitionType = "TEXT" | "MATH" | "DIAGRAM" | "Raw Content";
/**
 * @group Configuration
 */
type TConverstionState = "DIGITAL_EDIT" | "HANDWRITING";
/**
 * @group Configuration
 */
type TRecognitionConfiguration = {
    type: TRecognitionType;
    alwaysConnected: boolean;
    lang: string;
    math: TMathConfiguration;
    text: TTextConfiguration;
    diagram: TDiagramConfiguration;
    renderer: TRecognitionRendererConfiguration;
    export: TExportConfiguration;
    "raw-content": TRawContentConfiguration;
    gesture: {
        enable: boolean;
    };
    convert: TConvertionConfiguration;
};
/**
 * @group Configuration
 */
declare const DefaultRecognitionConfiguration: TRecognitionConfiguration;

/**
 * @group Configuration
 */
type TGuidesConfiguration = {
    enable: boolean;
    gap: number;
};
/**
 * @group Configuration
 */
declare const DefaultGuidesConfiguration: TGuidesConfiguration;
/**
 * @group Configuration
 */
type TSmartGuidesConfiguration = {
    enable: boolean;
};
/**
 * @group Configuration
 */
declare const DefaultSmartGuidesConfiguration: TSmartGuidesConfiguration;
/**
 * @group Configuration
 */
type TRenderingConfiguration = {
    minHeight: number;
    minWidth: number;
    smartGuide: TSmartGuidesConfiguration;
    guides: TGuidesConfiguration;
};
/**
 * @group Configuration
 */
declare const DefaultRenderingConfiguration: TRenderingConfiguration;

/**
 * @group Configuration
 */
type TProtocol = "WEBSOCKET" | "REST";
/**
 * @group Configuration
 */
type TSchene = "https" | "http";
/**
 * @group Configuration
 */
type TServerConfiguration = {
    protocol: TProtocol;
    scheme: TSchene;
    host: string;
    applicationKey: string;
    hmacKey: string;
    version: string;
    useWindowLocation?: boolean;
    websocket: {
        pingEnabled: boolean;
        pingDelay: number;
        maxPingLostCount: number;
        autoReconnect: boolean;
        maxRetryCount: number;
        fileChunkSize: number;
    };
};
/**
 * @group Configuration
 */
declare const DefaultServerConfiguration: TServerConfiguration;

/**
 * @group Configuration
 * @remarks
 * Configure when the action is triggered.
 *
 * POINTER_UP :   Action is triggered on every PenUP.
 *                This is the recommended mode for CDK V3 WebSocket recognitions.
 *
 * QUIET_PERIOD : Action is triggered after a quiet period in milli-seconds on every pointer up.
 *                The value is set to 1000 for example recognition will be triggered when the user stops writing for 1 seconds.
 *                This is the recommended mode for all REST discoveries.
 *
 * DEMAND :       Action is triggered on external demande
 */
type TTriggerConfiguration = {
    exportContent: "QUIET_PERIOD" | "POINTER_UP" | "DEMAND";
    exportContentDelay: number;
    resizeTriggerDelay: number;
};
/**
 * @group Configuration
 */
declare const DefaultTriggerConfiguration: TTriggerConfiguration;

/**
 * @group Configuration
 */
type TUndoRedoConfiguration = {
    maxStackSize: number;
};
/**
 * @group Event
 */
declare const DefaultUndoRedoConfiguration: TUndoRedoConfiguration;

/**
 * @group Configuration
 */
type TConfiguration = {
    server: TServerConfiguration;
    recognition: TRecognitionConfiguration;
    grabber: TGrabberConfiguration;
    rendering: TRenderingConfiguration;
    triggers: TTriggerConfiguration;
    "undo-redo": TUndoRedoConfiguration;
};
/**
 * @group Configuration
 */
declare const DefaultConfiguration: TConfiguration;
/**
 * @group Configuration
 */
declare class Configuration implements TConfiguration {
    #private;
    grabber: TGrabberConfiguration;
    recognition: TRecognitionConfiguration;
    rendering: TRenderingConfiguration;
    server: TServerConfiguration;
    triggers: TTriggerConfiguration;
    "undo-redo": TUndoRedoConfiguration;
    constructor(configuration?: PartialDeep<TConfiguration>);
    overrideDefaultConfiguration(configuration?: PartialDeep<TConfiguration>): void;
}

/**
 * @group Configuration
 */
type TLoggerConfiguration = {
    [key in keyof typeof LoggerClass]: LoggerLevel;
};
/**
 * @group Configuration
 */
declare const DefaultLoggerConfiguration: TLoggerConfiguration;

/**
 * @group Logger
 */
declare class Logger {
    instanceName: LoggerClass;
    level: LoggerLevel;
    constructor(instanceName: LoggerClass, level: LoggerLevel);
    debug(functionName: string, ...data: any): void;
    info(functionName: string, ...data: any): void;
    warn(functionName: string, ...data: any): void;
    error(functionName: string, ...error: any): void;
}

/**
 * @group Logger
 */
declare class LoggerManager {
    #private;
    static getLogger(name: LoggerClass): Logger;
    static setLoggerLevel(config: TLoggerConfiguration): void;
}

/**
 * @group Grabber
 */
interface IGrabber {
    attach(domElement?: HTMLElement): void;
    detach(domElement?: HTMLElement): void;
    onPointerDown(evt: PointerEvent, point: TPointer): void;
    onPointerMove(evt: PointerEvent, point: TPointer): void;
    onPointerUp(evt: PointerEvent, point: TPointer): void;
}

/**
 * @group Grabber
 */
declare class PointerEventGrabber implements IGrabber {
    #private;
    protected configuration: TGrabberConfiguration;
    protected domElement: HTMLElement;
    protected activePointerId?: number;
    protected prevent: (e: Event) => void;
    onPointerDown: (evt: PointerEvent, point: TPointer) => void;
    onPointerMove: (evt: PointerEvent, point: TPointer) => void;
    onPointerUp: (evt: PointerEvent, point: TPointer) => void;
    constructor(configuration: TGrabberConfiguration);
    protected roundFloat(oneFloat: number, requestedFloatPrecision: number): number;
    protected extractPoint(event: MouseEvent | TouchEvent): TPointer;
    protected pointerDownHandler: (evt: PointerEvent) => void;
    protected pointerMoveHandler: (evt: PointerEvent) => void;
    protected pointerUpHandler: (evt: PointerEvent) => void;
    private pointerOutHandler;
    attach(domElement: HTMLElement): void;
    detach(): void;
}

/**
 * @group Model/Export
 * @remarks values of X and Y are in millimeters
 */
type TJIIXStrokeItem = TJIIXBase & {
    timestamp?: string;
    X?: number[];
    Y?: number[];
    F?: number[];
    T?: number[];
    type: string;
    id: string;
    "bounding-box"?: TBoundingBox;
};
/**
 * @group Model/Export
 */
type TJIIXBase = {
    "bounding-box"?: TBoundingBox;
    items?: TJIIXStrokeItem[];
};
/**
 * @group Model/Export
 */
type TJIIXElement = TJIIXBase & {
    /** @hidden */
    [key: string]: unknown;
    id: string;
    type: string;
};
/**
 * @group Model/Export
 */
type TJIIXWord = TJIIXBase & {
    id?: string;
    label: string;
    candidates?: string[];
    "first-char"?: number;
    "last-char"?: number;
};
/**
 * @group Model/Export
 */
type TJIIXChar = TJIIXBase & {
    label: string;
    candidates?: string[];
    word: number;
    grid: TPoint[];
};
/**
 * @group Model/Export
 */
type TJIIXTextElement = TJIIXElement & {
    id: string;
    type: "Text";
    "bounding-box"?: TBoundingBox;
    label: string;
    words?: TJIIXWord[];
    chars?: TJIIXChar[];
};
/**
 * @group Model/Export
 */
type TJIIXNodeElement = TJIIXElement & {
    id: string;
    type: "Node";
    kind: "circle" | "ellipse" | "rectangle" | "triangle" | "parallelogram" | "polygon" | "rhombus";
};
/**
 * @group Model/Export
 */
type TJIIXNodeCircle = TJIIXNodeElement & {
    id: string;
    type: "Node";
    kind: "circle";
    cx: number;
    cy: number;
    r: number;
};
/**
 * @group Model/Export
 */
type TJIIXNodeEllipse = TJIIXNodeElement & {
    id: string;
    type: "Node";
    kind: "ellipse";
    cx: number;
    cy: number;
    rx: number;
    ry: number;
};
/**
 * @group Model/Export
 */
type TJIIXNodeRectangle = TJIIXNodeElement & {
    id: string;
    type: "Node";
    kind: "rectangle";
    height: number;
    width: number;
    x: number;
    y: number;
};
/**
 * @group Model/Export
 */
type TJIIXNodeTriangle = TJIIXNodeElement & {
    id: string;
    type: "Node";
    kind: "triangle";
    points: number[];
};
/**
 * @group Model/Export
 */
type TJIIXNodeParrallelogram = TJIIXNodeElement & {
    id: string;
    type: "Node";
    kind: "parallelogram";
    points: number[];
};
/**
 * @group Model/Export
 */
type TJIIXNodePolygon = TJIIXNodeElement & {
    id: string;
    type: "Node";
    kind: "polygon";
    points: number[];
};
/**
 * @group Model/Export
 */
type TJIIXNodeRhombus = TJIIXNodeElement & {
    id: string;
    type: "Node";
    kind: "rhombus";
    points: number[];
};
/**
 * @group Model/Export
 */
type TJIIXEdgeElement = TJIIXElement & {
    id: string;
    type: "Edge";
    kind: string;
};
/**
 * @group Model/Export
 */
type TJIIXEdgeLine = TJIIXEdgeElement & {
    id: string;
    type: "Edge";
    kind: "line";
    x1: number;
    x2: number;
    y1: number;
    y2: number;
    p1Decoration?: "arrow-head" | string;
    p2Decoration?: "arrow-head" | string;
};
/**
 * @group Model/Export
 */
type TJIIXEdgeArc = TJIIXEdgeElement & {
    id: string;
    type: "Edge";
    kind: "arc";
    cx: number;
    cy: number;
    rx: number;
    ry: number;
    phi: number;
    startAngle: number;
    sweepAngle: number;
};
/**
 * @group Model/Export
 */
type TJIIXExport = {
    type: string;
    id: string;
    "bounding-box"?: TBoundingBox;
    version: string;
    elements?: TJIIXElement[];
    label?: string;
    words?: TJIIXWord[];
    chars?: TJIIXChar[];
};
/**
 * @group Model/Export
 * @remarks
 * List all supported MIME types for export.
 * Attention the MIME types supported depend on the {@link TRecognitionType | type of recognition}
 */
type TExport = {
    /** @hidden */
    [key: string]: unknown;
    /**
     * @remarks vnd.myscript.jiix is used for text and raw-content exports
     */
    "application/vnd.myscript.jiix"?: TJIIXExport;
    /**
     * @remarks text/plain is only use for text export
     */
    "text/plain"?: string;
    /**
     * @remarks x-latex is only use for math export
     * @see {@link https://katex.org/docs/browser.html | katex} to render
     */
    "application/x-latex"?: string;
    /**
     * @remarks mathml+xml is only use for math export
     * @see {@link https://www.w3.org/Math/whatIsMathML.html | Mathematical Markup Language}
     */
    "application/mathml+xml"?: string;
    /**
     * @remarks svg+xml is only use for diagram export
     */
    "image/svg+xml"?: string;
    /**
     * @remarks vnd.openxmlformats-officedocument.presentationml.presentation is only use for diagram export
     * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/Blob | Blob}
     */
    "application/vnd.openxmlformats-officedocument.presentationml.presentation"?: Blob;
};

/**
 * @group Model
 */
type TRecognitionPositions = {
    lastSentPosition: number;
    lastReceivedPosition: number;
};
/**
 * @group Model
 */
interface IModel {
    readonly creationTime: number;
    modificationDate: number;
    positions: TRecognitionPositions;
    symbols: TSymbol[];
    exports?: TExport;
    converts?: TExport;
    width: number;
    height: number;
    rowHeight: number;
    idle: boolean;
    getClone(): IModel;
}

/**
 * @group Model
 */
declare class Model implements IModel {
    #private;
    readonly creationTime: number;
    modificationDate: number;
    positions: TRecognitionPositions;
    currentSymbol?: Stroke;
    symbols: Stroke[];
    exports?: TExport;
    converts?: TExport;
    width: number;
    height: number;
    rowHeight: number;
    idle: boolean;
    constructor(width?: number, height?: number, rowHeight?: number, creationDate?: number);
    protected computePressure(distance: number, globalDistance: number): number;
    protected filterPointByAcquisitionDelta(stroke: Stroke, point: TPointer, lastPointer?: TPointer): boolean;
    getStrokeFromPoint(point: TPoint): Stroke[];
    addPoint(stroke: Stroke, pointer: TPointer): void;
    addStroke(stroke: Stroke): void;
    updateStroke(updatedStroke: Stroke): void;
    removeStroke(id: string): void;
    removeStrokesFromPoint(point: TPoint): string[];
    extractUnsentStrokes(): Stroke[];
    initCurrentStroke(point: TPointer, pointerId: number, pointerType: string, style: TPenStyle, dpi?: number): void;
    appendToCurrentStroke(point: TPointer): void;
    endCurrentStroke(point: TPointer): void;
    updatePositionSent(position?: number): void;
    updatePositionReceived(): void;
    mergeExport(exports: TExport): void;
    mergeConvert(converts: TExport): void;
    getClone(): Model;
    clear(): void;
}

/**
 * @group Recognizer
 */
type TRestPostConfiguration = {
    lang: string;
    diagram?: TDiagramConfiguration;
    math?: TMathConfiguration;
    "raw-content"?: TRawContentConfiguration;
    text?: TTextConfiguration;
    export: TExportConfiguration;
};
/**
 * @group Recognizer
 */
type TRestPostData = {
    configuration: TRestPostConfiguration;
    xDPI: number;
    yDPI: number;
    contentType: string;
    conversionState?: TConverstionState;
    height: number;
    width: number;
    strokeGroups: TStrokeGroupToSend[];
};
/**
 * @group Recognizer
 */
declare class RestRecognizer {
    #private;
    protected serverConfiguration: TServerConfiguration;
    protected recognitionConfiguration: TRecognitionConfiguration;
    constructor(serverConfig: TServerConfiguration, recognitionConfig: TRecognitionConfiguration);
    get url(): string;
    get postConfig(): TRestPostConfiguration;
    protected buildData(model: Model): TRestPostData;
    protected post(data: unknown, mimeType: string): Promise<unknown>;
    protected tryFetch(data: TRestPostData, mimeType: string): Promise<TExport | never>;
    protected getMimeTypes(requestedMimeTypes?: string[]): string[];
    convert(model: Model, conversionState?: TConverstionState, requestedMimeTypes?: string[]): Promise<Model>;
    export(model: Model, requestedMimeTypes?: string[]): Promise<Model>;
    resize(model: Model): Promise<Model>;
}

/**
 * @group UndoRedo
 */
type TUndoRedoContext = {
    canUndo: boolean;
    canRedo: boolean;
    empty: boolean;
    stackIndex: number;
    possibleUndoCount: number;
    stack: IModel[];
};
/**
 * @group UndoRedo
 */
declare class UndoRedoContext implements TUndoRedoContext {
    canUndo: boolean;
    canRedo: boolean;
    empty: boolean;
    stackIndex: number;
    possibleUndoCount: number;
    stack: IModel[];
    constructor(model: IModel);
}

/**
 * @group UndoRedo
 */
declare class UndoRedoManager {
    #private;
    context: UndoRedoContext;
    configuration: TUndoRedoConfiguration;
    constructor(configuration: TUndoRedoConfiguration, model: IModel);
    get internalEvent(): InternalEvent;
    private updateCanUndoRedo;
    addModelToStack(model: IModel): void;
    removeLastModelInStack(): void;
    updateModelInStack(model: IModel): void;
    undo(): IModel;
    redo(): IModel;
    reset(model: IModel): void;
}

/**
 * @group Event
 */
declare class InternalEvent extends EventTarget {
    #private;
    private constructor();
    static getInstance(): InternalEvent;
    removeAllListeners(): void;
    emitSVGPatch(patchChange: TWSMessageEventSVGPatch): void;
    addSVGPatchListener(callback: (contentChange: TWSMessageEventSVGPatch) => void): void;
    emitExported(exports: TExport): void;
    addExportedListener(callback: (exports: TExport) => void): void;
    emitClearMessage(): void;
    addClearMessageListener(callback: () => void): void;
    emitError(err: Error): void;
    addErrorListener(callback: (err: Error) => void): void;
    emitWSClosed(): void;
    addWSClosedListener(callback: () => void): void;
    emitNotif(notif: {
        message: string;
        timeout?: number;
    }): void;
    addNotifListener(callback: (notif: {
        message: string;
        timeout?: number;
    }) => void): void;
    emitImportJIIX(jiix: TJIIXExport): void;
    addImportJIIXListener(callback: (jiix: TJIIXExport) => void): void;
    emitConvert(conversionState?: TConverstionState): void;
    addConvertListener(callback: (params?: {
        conversionState?: TConverstionState;
        mimeTypes?: string[];
    }) => void): void;
    emitClear(): void;
    addClearListener(callback: () => void): void;
    emitContextChange(context: TUndoRedoContext): void;
    addContextChangeListener(callback: (context: TUndoRedoContext) => void): void;
    emitIdle(idle: boolean): void;
    addIdleListener(callback: (idle: boolean) => void): void;
}

/**
 * @group Event
 */
declare class PublicEvent extends EventTarget {
    #private;
    private constructor();
    static getInstance(): PublicEvent;
    setElement(el: HTMLElement): void;
    emitLoaded(): void;
    emitExported(exports: TExport): void;
    emitChanged(undoRedoContext: TUndoRedoContext): void;
    emitIdle(idle: boolean): void;
    emitCleared(model?: IModel): void;
    emitConverted(exports: TExport): void;
    emitImported(exports: TExport): void;
}

/**
 * @group Recognizer
 */
type TWSMessageEvent = {
    type: string;
    [key: string]: unknown;
};
/**
 * @group Recognizer
 */
type TWSMessageEventError = {
    type: string;
    code?: number | string;
    message?: string;
    data?: {
        code: number | string;
        message: string;
    };
};
/**
 * @group Recognizer
 */
type TWSMessageEventHMACChallenge = TWSMessageEvent & {
    hmacChallenge: string;
    iinkSessionId: string;
};
/**
 * @group Recognizer
 */
type TWSMessageEventContentPackageDescriptionMessage = TWSMessageEvent & {
    contentPartCount: number;
};
/**
 * @group Recognizer
 */
type TWSMessageEventPartChange = TWSMessageEvent & {
    partIdx: number;
    partId: string;
    partCount: number;
};
/**
 * @group Recognizer
 */
type TWSMessageEventContentChange = TWSMessageEvent & {
    partId: string;
    canUndo: boolean;
    canRedo: boolean;
    empty: boolean;
    undoStackIndex: number;
    possibleUndoCount: number;
};
/**
 * @group Recognizer
 */
type TWSMessageEventExport = TWSMessageEvent & {
    partId: string;
    exports: TExport;
};
/**
 * @group Recognizer
 */
type TUpdatePatchType = "REPLACE_ALL" | "REMOVE_ELEMENT" | "REPLACE_ELEMENT" | "REMOVE_CHILD" | "APPEND_CHILD" | "INSERT_BEFORE" | "REMOVE_ATTRIBUTE" | "SET_ATTRIBUTE";
/**
 * @group Recognizer
 */
type TUpdatePatch = {
    type: TUpdatePatchType;
};
/**
 * @group Recognizer
 */
type TUpdatePatchReplaceAll = TUpdatePatch & {
    type: "REPLACE_ALL";
    svg: string;
};
/**
 * @group Recognizer
 */
type TUpdatePatchReplaceELement = TUpdatePatch & {
    type: "REPLACE_ELEMENT";
    id: string;
    svg: string;
};
/**
 * @group Recognizer
 */
type TUpdatePatchInsertBefore = TUpdatePatch & {
    type: "INSERT_BEFORE";
    refId: string;
    svg: string;
};
/**
 * @group Recognizer
 */
type TUpdatePatchRemoveElement = TUpdatePatch & {
    type: "REMOVE_ELEMENT";
    id: string;
};
/**
 * @group Recognizer
 */
type TUpdatePatchAppendChild = TUpdatePatch & {
    type: "APPEND_CHILD";
    parentId?: string;
    svg: string;
};
/**
 * @group Recognizer
 */
type TUpdatePatchRemoveChild = TUpdatePatch & {
    type: "REMOVE_CHILD";
    parentId: string;
    index: number;
};
/**
 * @group Recognizer
 */
type TUpdatePatchRemoveAttribut = TUpdatePatch & {
    type: "REMOVE_ATTRIBUTE";
    id?: string;
    name: string;
};
/**
 * @group Recognizer
 */
type TUpdatePatchSetAttribut = TUpdatePatch & {
    type: "SET_ATTRIBUTE";
    id?: string;
    name: string;
    value: string;
};
/**
 * @group Recognizer
 */
type TWSMessageEventSVGPatch = TWSMessageEvent & {
    updates: TUpdatePatch[];
    layer: ("MODEL" | "CAPTURE");
};

/**
 * A websocket dialog have this sequence :
 * --------------------------- Client --------------------------------------------------- Server ----------------------------------
 * init: send newContentPackage or restoreIInkSession           ==================>
 *                                                              <==================       ack
 * answer ack:
 *  send the hmac (if enable)                                   ==================>
 *  send the configuration                                      ==================>
 *                                                              <==================       contentPackageDescription
 * answer contentPackageDescription:
 *  send newContentPart or openContentPart                      ==================>
 *                                                              <==================        partChanged
 *                                                              <==================        contentChanged
 *                                                              <==================        newPart
 *                                                              <==================        svgPatch
 *
 * setPenStyle (send the parameters)                            ==================>
 * setTheme (send the parameters)                               ==================>
 * setPenStyleClasses (send the parameters)                     ==================>
 *                                                              <==================        svgPatch
 * addStrokes (send the strokes ) ============>
 *                                                              <==================        update
 */
/**
 * @group Recognizer
 */
declare class WSRecognizer {
    #private;
    protected serverConfiguration: TServerConfiguration;
    protected recognitionConfiguration: TRecognitionConfiguration;
    protected socket: WebSocket;
    protected pingCount: number;
    protected reconnectionCount: number;
    protected viewSizeHeight: number;
    protected viewSizeWidth: number;
    protected sessionId?: string;
    currentPartId?: string;
    protected currentErrorCode?: string | number;
    protected penStyle?: TPenStyle;
    protected penStyleClasses?: string;
    protected theme?: TTheme;
    protected connected?: DeferredPromise<void>;
    protected initialized?: DeferredPromise<void>;
    protected ackDeferred?: DeferredPromise<void>;
    protected addStrokeDeferred?: DeferredPromise<TExport>;
    protected exportDeferred?: DeferredPromise<TExport>;
    protected convertDeferred?: DeferredPromise<TExport>;
    protected importDeferred?: DeferredPromise<TExport>;
    protected resizeDeferred?: DeferredPromise<void>;
    protected undoDeferred?: DeferredPromise<TExport>;
    protected redoDeferred?: DeferredPromise<TExport>;
    protected clearDeferred?: DeferredPromise<TExport>;
    protected importPointEventsDeferred?: DeferredPromise<TExport>;
    protected waitForIdleDeferred?: DeferredPromise<void>;
    url: string;
    constructor(serverConfig: TServerConfiguration, recognitionConfig: TRecognitionConfiguration);
    get mimeTypes(): string[];
    get internalEvent(): InternalEvent;
    protected infinitePing(): void;
    protected openCallback(): void;
    protected rejectDeferredPending(error: Error): void;
    protected closeCallback(evt: CloseEvent): void;
    protected manageAckMessage(websocketMessage: TWSMessageEvent): Promise<void>;
    protected manageContentPackageDescriptionMessage(): Promise<void>;
    protected managePartChangeMessage(websocketMessage: TWSMessageEvent): void;
    protected manageExportMessage(websocketMessage: TWSMessageEvent): void;
    protected manageWaitForIdle(): Promise<void>;
    protected manageErrorMessage(websocketMessage: TWSMessageEvent): void;
    protected manageContentChangeMessage(websocketMessage: TWSMessageEvent): void;
    protected manageSVGPatchMessage(websocketMessage: TWSMessageEvent): void;
    protected messageCallback(message: MessageEvent<string>): void;
    init(height: number, width: number): Promise<void>;
    send(message: TWSMessageEvent): Promise<void>;
    addStrokes(strokes: Stroke[]): Promise<TExport>;
    setPenStyle(penStyle: TPenStyle): Promise<void>;
    setPenStyleClasses(penStyleClasses: string): Promise<void>;
    setTheme(theme: TTheme): Promise<void>;
    export(model: Model, requestedMimeTypes?: string[]): Promise<Model>;
    import(model: Model, data: Blob, mimeType?: string): Promise<Model>;
    resize(model: Model): Promise<Model>;
    importPointEvents(strokes: Stroke[]): Promise<TExport>;
    convert(model: Model, conversionState?: TConverstionState): Promise<Model>;
    waitForIdle(): Promise<void>;
    undo(model: Model): Promise<Model>;
    redo(model: Model): Promise<Model>;
    clear(model: Model): Promise<Model>;
    close(code: number, reason: string): void;
    destroy(): void;
}

/**
 * @group Behavior
 */
type TBehaviorOptions = {
    configuration: TConfiguration;
    behaviors?: {
        grabber?: IGrabber;
        recognizer?: RestRecognizer | WSRecognizer;
    };
    penStyle?: TStyle;
    theme?: TTheme;
    logger?: TLoggerConfiguration;
};
/**
 * @group Behavior
 */
interface IBehaviors {
    name: string;
    grabber: IGrabber;
    context: TUndoRedoContext;
    intention: Intention;
    get currentPenStyle(): TStyle;
    get model(): IModel;
    get penStyle(): TStyle;
    setPenStyle(penStyle?: PartialDeep<TStyle>): Promise<void>;
    get penStyleClasses(): string;
    setPenStyleClasses(penStyleClasses?: string): Promise<void>;
    get theme(): TTheme;
    setTheme(theme?: PartialDeep<TTheme>): Promise<void>;
    get configuration(): TConfiguration;
    set configuration(conf: TConfiguration);
    init(element: HTMLElement): Promise<void>;
    export(mimeTypes?: string[]): Promise<IModel>;
    convert(conversionState?: TConverstionState, requestedMimeTypes?: string[]): Promise<IModel>;
    resize(height: number, width: number): Promise<IModel>;
    undo(): Promise<IModel>;
    redo(): Promise<IModel>;
    waitForIdle?(): Promise<void>;
    importPointEvents(strokes: PartialDeep<TStroke>[]): Promise<IModel>;
    import?(data: Blob, mimeType?: string): Promise<IModel>;
    clear(): Promise<IModel>;
    destroy(): Promise<void>;
}

/**
 * @group Renderer
 */
declare class CanvasRendererShape {
    #private;
    symbols: {
        table: string;
        ellipse: string;
        line: string;
    };
    protected phi(angle: number): number;
    protected drawEllipseArc(context2D: CanvasRenderingContext2D, shapeEllipse: TCanvasShapeEllipseSymbol): TPoint[];
    protected drawLine(context2D: CanvasRenderingContext2D, p1: TPoint, p2: TPoint): void;
    protected drawArrowHead(context2D: CanvasRenderingContext2D, headPoint: TPoint, angle: number, length: number): void;
    protected drawShapeEllipse(context2D: CanvasRenderingContext2D, shapeEllipse: TCanvasShapeEllipseSymbol): void;
    protected drawShapeLine(context2D: CanvasRenderingContext2D, shapeLine: TCanvasShapeLineSymbol): void;
    draw(context2D: CanvasRenderingContext2D, symbol: TSymbol): void;
}

/**
 * @group Renderer
 */
declare class CanvasRendererStroke {
    #private;
    protected renderArc(context2d: CanvasRenderingContext2D, center: TPointer, radius: number): void;
    protected renderLine(context2d: CanvasRenderingContext2D, begin: TPointer, end: TPointer, width: number): void;
    protected renderFinal(context2d: CanvasRenderingContext2D, begin: TPointer, end: TPointer, width: number): void;
    protected renderQuadratic(context2d: CanvasRenderingContext2D, begin: TPointer, end: TPointer, ctrl: TPointer, width: number): void;
    draw(context2d: CanvasRenderingContext2D, stroke: Stroke): void;
}

/**
 * @group Renderer
 */
declare class CanvasRendererText {
    #private;
    symbols: {
        char: string;
        string: string;
        textLine: string;
    };
    protected drawUnderline(context2D: CanvasRenderingContext2D, textUnderline: TCanvasTextUnderlineSymbol, underline: TCanvasUnderLineSymbol): void;
    protected drawText(context2D: CanvasRenderingContext2D, text: TCanvasTextSymbol): void;
    protected drawTextLine(context2D: CanvasRenderingContext2D, textUnderline: TCanvasTextUnderlineSymbol): void;
    draw(context2D: CanvasRenderingContext2D, symbol: TSymbol): void;
}

/**
 * @group Renderer
 */
declare class CanvasRenderer {
    #private;
    configuration: TRenderingConfiguration;
    strokeRenderer: CanvasRendererStroke;
    shapeRenderer: CanvasRendererShape;
    textRenderer: CanvasRendererText;
    context: {
        parent: HTMLElement;
        renderingCanvas: HTMLCanvasElement;
        renderingCanvasContext: CanvasRenderingContext2D;
        capturingCanvas: HTMLCanvasElement;
        capturingCanvasContext: CanvasRenderingContext2D;
    };
    constructor(config: TRenderingConfiguration);
    protected createCanvas(type: string): HTMLCanvasElement;
    protected resizeContent(): void;
    protected drawSymbol(context2D: CanvasRenderingContext2D, symbol: TSymbol): void;
    init(element: HTMLElement): void;
    drawModel(model: IModel): void;
    drawPendingStroke(stroke: Stroke | undefined): void;
    resize(model: IModel): void;
    destroy(): void;
}

/**
 * @group Renderer
 */
declare class SVGStroker {
    protected getArcPath(center: TPointer, radius: number): string;
    protected getLinePath(begin: TPointer, end: TPointer, width: number): string;
    protected getFinalPath(begin: TPointer, end: TPointer, width: number): string;
    protected getQuadraticPath(begin: TPointer, end: TPointer, central: TPointer, width: number): string;
    protected buildSVGPath(stroke: TStroke): string;
    drawStroke(svgElement: SVGElement, stroke: TStroke, attrs?: {
        name: string;
        value: string;
    }[]): void;
}

/**
 * @group Renderer
 */
declare class WSSVGRenderer {
    #private;
    config: TRenderingConfiguration;
    stroker: SVGStroker;
    context: {
        parent: HTMLElement;
    };
    constructor(config: TRenderingConfiguration);
    init(element: HTMLElement): void;
    protected drawStroke(svgElement: SVGElement, stroke: TStroke): void;
    protected replaceAll(layerName: string, update: TUpdatePatchReplaceAll): void;
    protected replaceElement(update: TUpdatePatchReplaceELement): void;
    protected appendChild(layerName: string, update: TUpdatePatchAppendChild): void;
    protected removeChild(update: TUpdatePatchRemoveChild): void;
    protected removeElement(update: TUpdatePatchRemoveElement): void;
    protected insertBefore(update: TUpdatePatchInsertBefore): void;
    protected setAttribute(update: TUpdatePatchSetAttribut): void;
    protected removeAttribute(update: TUpdatePatchRemoveAttribut): void;
    updateLayer(layerName: string, update: TUpdatePatch): void;
    updatesLayer(layerName: string, updates: TUpdatePatch[]): void;
    clearPendingStroke(): void;
    drawPendingStroke(stroke: TStroke): void;
    clearErasingStrokes(): void;
    resize(model: IModel): void;
    destroy(): void;
}

/**
 * @group Behavior
 */
declare class RestBehaviors implements IBehaviors {
    #private;
    name: string;
    grabber: PointerEventGrabber;
    renderer: CanvasRenderer;
    recognizer: RestRecognizer;
    undoRedoManager: UndoRedoManager;
    styleManager: StyleManager;
    intention: Intention;
    constructor(options: PartialDeep<TBehaviorOptions>);
    protected onPointerDown(evt: PointerEvent, point: TPointer): void;
    protected onPointerMove(_evt: PointerEvent, point: TPointer): void;
    protected onPointerUp(_evt: PointerEvent, point: TPointer): Promise<void>;
    get internalEvent(): InternalEvent;
    get model(): Model;
    get context(): TUndoRedoContext;
    get currentPenStyle(): TPenStyle;
    get penStyle(): TPenStyle;
    setPenStyle(penStyle?: TPenStyle | undefined): Promise<void>;
    get penStyleClasses(): string;
    setPenStyleClasses(penStyleClasses?: string | undefined): Promise<void>;
    get theme(): TTheme;
    setTheme(theme?: PartialDeep<TTheme>): Promise<void>;
    get configuration(): TConfiguration;
    init(domElement: HTMLElement): Promise<void>;
    drawCurrentStroke(): void;
    updateModelRendering(): Promise<IModel>;
    export(mimeTypes?: string[]): Promise<IModel>;
    convert(conversionState?: TConverstionState, requestedMimeTypes?: string[]): Promise<IModel>;
    importPointEvents(strokes: PartialDeep<TStroke>[]): Promise<IModel>;
    resize(height: number, width: number): Promise<IModel>;
    undo(): Promise<IModel>;
    redo(): Promise<IModel>;
    clear(): Promise<IModel>;
    destroy(): Promise<void>;
}

/**
 * @group Behavior
 */
declare class WSBehaviors implements IBehaviors {
    #private;
    name: string;
    grabber: PointerEventGrabber;
    renderer: WSSVGRenderer;
    recognizer: WSRecognizer;
    undoRedoManager: UndoRedoManager;
    styleManager: StyleManager;
    intention: Intention;
    constructor(options: PartialDeep<TBehaviorOptions>);
    get internalEvent(): InternalEvent;
    get model(): Model;
    get context(): TUndoRedoContext;
    get configuration(): TConfiguration;
    get currentPenStyle(): TPenStyle;
    get penStyle(): TPenStyle;
    setPenStyle(penStyle?: PartialDeep<TPenStyle>): Promise<void>;
    get penStyleClasses(): string;
    setPenStyleClasses(penClass?: string): Promise<void>;
    get theme(): TTheme;
    setTheme(theme?: PartialDeep<TTheme>): Promise<void>;
    protected onExport(exports: TExport): void;
    protected onPointerDown(evt: PointerEvent, point: TPointer): void;
    protected onPointerMove(_evt: PointerEvent, point: TPointer): void;
    protected onPointerUp(_evt: PointerEvent, point: TPointer): Promise<void>;
    protected onSVGPatch(evt: TWSMessageEventSVGPatch): void;
    init(domElement: HTMLElement): Promise<void>;
    drawCurrentStroke(): void;
    synchronizeModelWithBackend(): Promise<IModel>;
    waitForIdle(): Promise<void>;
    export(mimeTypes?: string[]): Promise<IModel>;
    convert(conversionState?: TConverstionState): Promise<IModel>;
    import(data: Blob, mimeType?: string): Promise<IModel>;
    importPointEvents(strokes: PartialDeep<TStroke>[]): Promise<IModel>;
    resize(height: number, width: number): Promise<IModel>;
    undo(): Promise<IModel>;
    redo(): Promise<IModel>;
    clear(): Promise<IModel>;
    destroy(): Promise<void>;
}

/**
 * @group Editor
 */
type HTMLEditorElement = HTMLElement & {
    editor: Editor;
};
/**
 * @group Editor
 */
declare class Editor {
    #private;
    logger: Logger;
    wrapperHTML: HTMLEditorElement;
    constructor(wrapperHTML: HTMLElement, options: PartialDeep<TBehaviorOptions>, globalClassCss?: string);
    get loggerConfiguration(): TLoggerConfiguration;
    set loggerConfiguration(loggerConfig: TLoggerConfiguration);
    get initializationPromise(): Promise<void>;
    get model(): IModel;
    get behaviors(): IBehaviors;
    get configuration(): TConfiguration;
    set configuration(configuration: TConfiguration);
    get intention(): Intention;
    set intention(i: Intention);
    get events(): PublicEvent;
    get internalEvents(): InternalEvent;
    get context(): TUndoRedoContext;
    get grabber(): IGrabber;
    get currentPenStyle(): TPenStyle;
    get penStyle(): TPenStyle;
    set penStyle(ps: PartialDeep<TPenStyle>);
    get theme(): TTheme;
    set theme(theme: PartialDeep<TTheme>);
    get penStyleClasses(): string;
    set penStyleClasses(styleClasses: string);
    get gestures(): boolean;
    set gestures(apply: boolean);
    initialize(): Promise<void>;
    waitForIdle(): Promise<void>;
    undo(): Promise<IModel>;
    redo(): Promise<IModel>;
    clear(): Promise<IModel>;
    resize(): Promise<IModel>;
    export(mimeTypes?: string[]): Promise<IModel>;
    convert(params?: {
        conversionState?: TConverstionState;
        mimeTypes?: string[];
    }): Promise<IModel | never>;
    import(data: Blob | string | TJIIXExport, mimeType?: string): Promise<IModel | never>;
    importPointEvents(strokes: PartialDeep<TStroke>[]): Promise<IModel>;
}

/**
 * @group SmartGuide
 */
declare class SmartGuide {
    #private;
    uuid: string;
    margin: TMarginConfiguration;
    renderingConfiguration: TRenderingConfiguration;
    jiix?: TJIIXExport;
    lastWord?: TJIIXWord;
    wordToChange?: TJIIXWord;
    constructor();
    get internalEvent(): InternalEvent;
    init(domElement: HTMLElement, margin: TMarginConfiguration, renderingConfiguration: TRenderingConfiguration): void;
    resize(): void;
    update(exports: TJIIXExport): void;
    clear(): void;
    destroy(): void;
}

export { AbstractSymbol, CanvasRenderer, CanvasRendererShape, CanvasRendererStroke, CanvasRendererText, Configuration, DefaultConfiguration, DefaultConvertionConfiguration, DefaultDebugConfiguration, DefaultDiagramConfiguration, DefaultDiagramConvertConfiguration, DefaultEraserConfiguration, DefaultExportConfiguration, DefaultGrabberConfiguration, DefaultGuidesConfiguration, DefaultJiixConfiguration, DefaultListenerConfiguration, DefaultLoggerConfiguration, DefaultMarginConfiguration, DefaultMathConfiguration, DefaultMathUndoRedoConfiguration, DefaultPenStyle, DefaultRawContentConfiguration, DefaultRawContentRecognitionConfiguration, DefaultRecognitionConfiguration, DefaultRecognitionRendererConfiguration, DefaultRenderingConfiguration, DefaultServerConfiguration, DefaultSmartGuidesConfiguration, DefaultSolverConfiguration, DefaultTextConfiguration, DefaultTextGuidesConfiguration, DefaultTheme, DefaultTriggerConfiguration, DefaultUndoRedoConfiguration, DeferredPromise, Editor, Error$1 as Error, EventType, ExportType, type HTMLEditorElement, type IBehaviors, type IGrabber, type IModel, Intention, InternalEvent, InternalEventType, Logger, LoggerClass, LoggerLevel, LoggerManager, Model, type PartialDeep, PointerEventGrabber, PublicEvent, RestBehaviors, RestRecognizer, SVGStroker, SmartGuide, Stroke, StyleHelper, StyleManager, SymbolType, type TAngleUnit, type TBehaviorOptions, type TBoundingBox, type TCanvasShapeEllipseSymbol, type TCanvasShapeLineSymbol, type TCanvasShapeTableLineSymbol, type TCanvasShapeTableSymbol, type TCanvasTextSymbol, type TCanvasTextUnderlineSymbol, type TCanvasUnderLineSymbol, type TConfiguration, type TConverstionState, type TConvertionConfiguration, type TDiagramConfiguration, type TDiagramConvertConfiguration, type TEraserConfiguration, type TExport, type TExportConfiguration, type TGrabberConfiguration, type TGuidesConfiguration, type TImageConfiguration, type TImageViewportConfiguration, type TJIIXBase, type TJIIXChar, type TJIIXEdgeArc, type TJIIXEdgeElement, type TJIIXEdgeLine, type TJIIXElement, type TJIIXExport, type TJIIXNodeCircle, type TJIIXNodeElement, type TJIIXNodeEllipse, type TJIIXNodeParrallelogram, type TJIIXNodePolygon, type TJIIXNodeRectangle, type TJIIXNodeRhombus, type TJIIXNodeTriangle, type TJIIXStrokeItem, type TJIIXTextElement, type TJIIXWord, type TJiixConfiguration, type TListenerConfiguration, type TLoggerConfiguration, type TMarginConfiguration, type TMathConfiguration, type TMathMLExport, type TMathMLFlavor, type TMathUndoRedoConfiguration, type TPenStyle, type TPoint, type TPointer, type TProtocol, type TRawContentConfiguration, type TRawContentRecognitionConfiguration, type TRecognitionConfiguration, type TRecognitionPositions, type TRecognitionRendererConfiguration, type TRecognitionRendererDebugConfiguration, type TRecognitionType, type TRenderingConfiguration, type TRestPostConfiguration, type TRestPostData, type TRoundingMode, type TSchene, type TSegment, type TServerConfiguration, type TSmartGuidesConfiguration, type TSolverConfiguration, type TSolverOptions, type TStroke, type TStrokeGroup, type TStrokeGroupToSend, type TStrokeToSend, type TStyle, type TSymbol, type TTextConfConfiguration, type TTextConfiguration, type TTextGuidesConfiguration, type TTheme, type TThemeMath, type TThemeMathSolved, type TThemeText, type TTriggerConfiguration, type TUndoRedoConfiguration, type TUndoRedoContext, type TUndoRedoMode, type TUpdatePatch, type TUpdatePatchAppendChild, type TUpdatePatchInsertBefore, type TUpdatePatchRemoveAttribut, type TUpdatePatchRemoveChild, type TUpdatePatchRemoveElement, type TUpdatePatchReplaceAll, type TUpdatePatchReplaceELement, type TUpdatePatchSetAttribut, type TUpdatePatchType, type TWSMessageEvent, type TWSMessageEventContentChange, type TWSMessageEventContentPackageDescriptionMessage, type TWSMessageEventError, type TWSMessageEventExport, type TWSMessageEventHMACChallenge, type TWSMessageEventPartChange, type TWSMessageEventSVGPatch, UndoRedoContext, UndoRedoManager, WSBehaviors, WSRecognizer, WSSVGRenderer, computeAngleAxeRadian, computeDistance, computeDistanceBetweenPointAndSegment, computeHmac, computeLinksPointers, computeMiddlePointer, computeNearestPointOnSegment, convertMillimeterToPixel, convertPartialStrokesToStrokes, convertPixelToMillimeter, createPointsOnSegment, createUUID, getAvailableFontList, getAvailableLanguageList, isBetween, isVersionSuperiorOrEqual, mergeDeep, scalaire };
//# sourceMappingURL=iink.d.ts.map
